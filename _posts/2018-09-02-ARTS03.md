---
layout:     post
title:      "ARTS03"
subtitle:   "Algorithms-Review-Tip-Share"
date:       2018-09-02 15:30:00
author:     "Kaelzhang"
header-img: "img/post-bg-js-module.jpg"
catalog:    true
tags:
    - ARTS
---

# Algorithm

## 53. 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

> 输入: [-2,1,-3,4,-1,2,1,-5,4],
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

**解决方案：**


```java
class Solution {
    public static int maxSubArray(int[] nums) {
        int max = 0;
        int acc = 0;

        if (nums.length > 0){
            max = nums[0];
        }

        for (int num : nums) {
            int newNum = acc + num;
            if (num < 0 && newNum < 0){
                acc = 0;
            }
            else{
                acc = newNum;
            }
            if (newNum > max){
                max = newNum;
            }
        }

        return max;
    }
}
```

# Review
[11个提升Java代码质量的实践和工具](https://www.romexsoft.com/blog/improve-java-code-quality/)

本文较全面的介绍了提升代码质量关键实践和工具，在整理过程中容入了我本人在实践中的一些理解。软件开发方法是一组模式和规则，用于构建，规划和控制软件解决方案开发的过程。 为了有效管理开发过程，项目经理必须选择最适合项目的开发方法。

本文还给出了需要遵循的编程语言风格指南：

* 坚持SOLID原则。
* 为方法和变量提供描述性名称。
* 不要过度设计。
* 使用设计模式。
* 不要重新发明轮子并使用第三方框架。
* 使用高效的数据结构和算法。
* 创建单元测试。
* 文档化项目的所有方面。
* 将项目的所有内容都保留在版本控制系统下。

## 提升代码质量的实践
### 结对编程
结对编程的要点：

* 知识共享
* 代码质量改进
* 团队内部沟通改善
* 高效工作

结对编程应做到1+1>2

### 编码规范

包括文件组织，缩进，注释，声明，语句，空格，命名约定，编程实践和原则，体系结构最佳实践等。

如果编码标准在整个开发过程中遵循并一致地应用，将来维护和扩展代码、重构代码以及解决集成冲突将更容易。

编码规范的要点：

* 40％ - 80％的软件成本用于维护。
* 几乎没有任何软件仅由作者维护。
* 提高了软件的可读性，使程序员能更快地理解代码。
* 代码评审的参考物。

花时间辩论和争论编码规范是有道理的，因为它是为节省未来的时间和努力做出的宝贵贡献。大多数团队同意的规则应被视为“强制性”，其他规则可视为“可选”。

### 代码评审

代码评审的要点：

* 随时开展（结对编程就是一个好的方式）
* 高效开展（每次时间和内容要把控）
* 知识共享
* 代码质量改进

### 单元测试

单元测试的要点：

* 代码可测的基础
* 修改代码时的防护网

如果不能做到全覆盖，要确保核心模块的单元测试覆盖。编写单元测试所耗费的时间，将大大减少在调试和集成上浪费的时间。

### 测试驱动开发

一种开发软件的方法，该软件结合了代码级的单元测试，编码和重构。

测试驱动开发要点：

* 促使你思考代码如何被使用
* 是对多种实践的整合（重构、单元测试、简单设计、结对编程等）
* 代码完成自动化测试用例也完成
* 更自然的工作分解和拆分
* 频繁的自动化测试
* 固定的步骤和套路

### 持续集成

一种开发实践，需要开发人员每天多次将代码集成到源代码管理器（SVN或Git）。

持续集成的要点：

* 将代码变更快速集成
* 系统级的集成
* 整合自动化测试
* 更快的反馈速度

### 演示会 

通常在迭代结束时进行。目的是向其他团队成员，客户和利益相关者展示团队在迭代上取得的工作成果。

演示会的要点：

* 代码处于易于发布的状态
* 获取客户反馈，保证项目在正确的方向上
* 收获信心

## 提升代码质量的工具

> “没有人从不犯错”
> “所谓的高手只是把你可能犯的错都早已犯过一遍”
> “人会犯错但自动化不会”

通过提升代码的实践也无法完全保证代码就没有问题，并且也没人想要评审数万行代码，这时需要额外的一双永不疲惫眼睛来审视你的代码。幸运的是，有许多工具可以辅助团队来控制代码质量。这些工具通常用于质量分析并构建一些有用的报告，这些报告通常由Jenkins持续集成服务器发布。同样这些工具也可以集成到IDE中融入开发工作中去。

### Checkstyle

Checkstyle是一个免费的开源静态代码分析工具，用于软件开发，用于检查Java代码是否符合已建立的编码规范。
Checkstyle附带预定义规则，有助于维护代码标准。

### PMD

一种静态代码分析工具，能够自动检测各种潜在的错误以及不安全或次优代码，例如可能的错误，死代码，次优代码，过于复杂的表达式和重复的代码。

PMD更多地关注缺陷检测。附带丰富且高度可配置的规则集，可以轻松配置这些规则并选定给项目使用哪些特定规则。

检查内容有：

* 空try / catch / finally / switch块。
* 空if / while语句。
* 死代码。
* 实现而非接口。
* 太复杂的方法。
* 具有高Cyclomatic Complexity的类。
* 未使用的局部变量，参数和私有方法。
* 重载equals方法未重载hashcode方法。
* 效率低下的String / StringBuffer用法。
* 重复代码。

### FindBugs

FindBugs是一个开源的Java代码质量工具。 FindBugs不涉及格式或编码标准，偏向于最佳实践，包括错误检查、性能问题。

线程同步问题
空指针解引用
无限递归循环
API方法误用.

FindBugs使用Java字节码而不是源代码来检测。 与PMD或Checkstyle相比，它能够以相对较高的精度检测相当多的不同问题。

四个等级：

* 最可怕级
* 可怕级
* 不安级
* 关注级

### SonarQube

一个开源平台，最初于2007年推出，开发人员用它来管理源代码质量。 Sonar旨在支持公司内部代码质量的全球持续改进策略，因此可用作质量管理的共享中央系统。支持多种语言并可与多个工具集成。还有：web化、仪表化、插件化等特点。


# Tip
下面是在TDD讨论群中，谈到的程序员IDE必备插件：

1. IdeaVim：IDEA Intellij的vim插件，大部分vim操作都支持。
2. Relative line number：该插件能够显示所在行与其它行的相对行数，便于使用vi命令上移下移行数。
3. cucumber for java：BDD风格的测试用例插件。
3. presentation assistant:这款插件可以实时的在Intellij屏幕底部展示当前按下的快捷键，包括Windows的快捷键和Mac的快捷键，可以帮助您记忆快捷键，清楚当前的行为(Action)。
4. save actions：此插件能够帮助你每次修改内容之后，都能自动格式化、重新排序package的顺序
5. lombok plugin：帮我们省去了手动输入get、set的烦恼。

# Share

关于Java的强引用、软引用、弱引用、虚引用：

强引用（Strong Reference）：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是**强可达的(strongly reachable)，那么它就不被回收**。
软引用（Soft Reference）：软引用和弱引用的区别在于，若一个对象是**弱引用可达那么无论当前内存是否充足它都会被GC所回收**，而**软引用可达的对象在内存不充足时才会被回收**，因此软引用要比弱引用“强”一些。
虚引用（Phantom Reference）：虚引用是Java中最弱的引用，那么它弱到什么程度呢？它是如此脆弱以至于我们**通过虚引用甚至无法获取到被引用的对象**，虚引用存在的唯一作用就是**当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收**。

| 引用类型 | GC时间 | 用途 | 生存时间 |
| --- | --- | --- | --- |
| 强引用 | 从来不会 | 对象的一般状态 | JVM停止运行时终止 |
| 软引用 | 在内存不足时 | 对象缓存 | 内存不足时终止 |
| 弱引用 | 在垃圾回收时 | 对象缓存 | gc运行后终止 |
| 虚引用 | Unknown | Unknown | Unknown |

